{
  "function": "CONCAT_WS",
  "dialect": "spark",
  "basis_size": 24,
  "completeness": {
    "spanning": true,
    "surjectivity": 1.0,
    "status": "COMPLETE"
  },
  "parameters": [
    {
      "name": "sep",
      "position": 1,
      "real_domain": "STRING ∪ {NULL} ∪ (all castable types: INTEGER, DECIMAL, BOOLEAN, etc.)",
      "partitions": [
        {
          "id": "P_sep_null",
          "predicate": "sep IS NULL",
          "representative": "NULL",
          "why_distinct": "NULL separator forces entire function to return NULL (override)"
        },
        {
          "id": "P_sep_empty",
          "predicate": "sep IS NOT NULL AND len(sep) = 0",
          "representative": "''",
          "why_distinct": "Empty separator → direct concatenation without delimiter"
        },
        {
          "id": "P_sep_single",
          "predicate": "sep IS NOT NULL AND len(sep) = 1",
          "representative": "','",
          "why_distinct": "Single character separator → standard use case"
        },
        {
          "id": "P_sep_multi",
          "predicate": "sep IS NOT NULL AND len(sep) > 1",
          "representative": "'--'",
          "why_distinct": "Multi-character separator → tests delimiter expansion"
        },
        {
          "id": "P_sep_int",
          "predicate": "sep is INTEGER type",
          "representative": "1",
          "why_distinct": "Integer separator → implicit cast to string behavior"
        }
      ],
      "spanning_proof": "{NULL} ∪ {s: len(s)=0} ∪ {s: len(s)=1} ∪ {s: len(s)>1} ∪ {castable types} = all accepted inputs. Every possible separator value falls into exactly one partition. No gap."
    },
    {
      "name": "args",
      "position": "2+",
      "variadic": true,
      "real_domain": "Zero to many arguments of type STRING ∪ ARRAY<STRING> ∪ {NULL} ∪ (all castable scalar types: INTEGER, DECIMAL, BOOLEAN, DATE, TIMESTAMP, etc.)",
      "partitions": [
        {
          "id": "P_no_args",
          "predicate": "arg count = 0",
          "representative": "(empty)",
          "why_distinct": "No arguments after separator → edge case → empty output"
        },
        {
          "id": "P_all_null_scalars",
          "predicate": "All scalar arguments are NULL",
          "representative": "CAST(NULL AS STRING), CAST(NULL AS STRING)",
          "why_distinct": "All arguments skipped → empty output (distinct from no args)"
        },
        {
          "id": "P_single_value",
          "predicate": "Exactly 1 non-NULL value after NULL filtering",
          "representative": "'a'",
          "why_distinct": "No separator appears in output (only one survivor)"
        },
        {
          "id": "P_multiple_values",
          "predicate": "Multiple non-NULL string values",
          "representative": "'a', 'b', 'c'",
          "why_distinct": "Standard joining behavior → separator between values"
        },
        {
          "id": "P_mix_null_values",
          "predicate": "Mix of NULL and non-NULL scalars",
          "representative": "'a', NULL, 'b'",
          "why_distinct": "NULL skipping behavior → gap in argument list"
        },
        {
          "id": "P_empty_strings",
          "predicate": "Contains empty string '' (not NULL)",
          "representative": "'', 'a', ''",
          "why_distinct": "Empty string ≠ NULL → kept → consecutive separators in output"
        },
        {
          "id": "P_integer_values",
          "predicate": "Integer scalar arguments",
          "representative": "1, 2, 3",
          "why_distinct": "Integer to string implicit cast"
        },
        {
          "id": "P_decimal_values",
          "predicate": "Decimal scalar arguments",
          "representative": "1.5, 2.75",
          "why_distinct": "Decimal to string cast → precision preservation"
        },
        {
          "id": "P_negative_numbers",
          "predicate": "Negative numeric arguments",
          "representative": "-1, -2.5",
          "why_distinct": "Sign handling in cast"
        },
        {
          "id": "P_boolean_values",
          "predicate": "Boolean scalar arguments",
          "representative": "TRUE, FALSE",
          "why_distinct": "Boolean to string cast → lowercase 'true'/'false'"
        },
        {
          "id": "P_date_value",
          "predicate": "DATE type argument",
          "representative": "DATE '2024-01-01'",
          "why_distinct": "Date to string cast → ISO format"
        },
        {
          "id": "P_timestamp_value",
          "predicate": "TIMESTAMP type argument",
          "representative": "TIMESTAMP '2024-01-01 10:30:00'",
          "why_distinct": "Timestamp to string cast → ISO format with time"
        },
        {
          "id": "P_array_strings",
          "predicate": "ARRAY<STRING> argument with non-NULL elements",
          "representative": "array('a', 'b')",
          "why_distinct": "Array expansion behavior → elements become individual values"
        },
        {
          "id": "P_array_with_nulls",
          "predicate": "ARRAY<STRING> containing NULL elements",
          "representative": "array('a', NULL, 'b')",
          "why_distinct": "NULL handling within array expansion"
        },
        {
          "id": "P_empty_array",
          "predicate": "ARRAY<STRING> with zero elements",
          "representative": "array()",
          "why_distinct": "Empty array → contributes nothing → distinct from scalar NULL"
        },
        {
          "id": "P_array_plus_scalar",
          "predicate": "Mix of ARRAY and scalar arguments",
          "representative": "array('a', 'b'), 'c'",
          "why_distinct": "Array expanded then joined with scalar → flattening behavior"
        },
        {
          "id": "P_mixed_types",
          "predicate": "Multiple different types in one call",
          "representative": "1, 'text', TRUE, NULL",
          "why_distinct": "All type casts + NULL skipping in one query"
        },
        {
          "id": "P_nested_function",
          "predicate": "Function expression arguments",
          "representative": "UPPER('abc'), LOWER('XYZ')",
          "why_distinct": "Expression evaluation then joining"
        },
        {
          "id": "P_all_null_array",
          "predicate": "ARRAY with all NULL elements",
          "representative": "array(NULL, NULL)",
          "why_distinct": "Array expansion yields no survivors → empty output"
        },
        {
          "id": "P_falsy_values",
          "predicate": "Falsy but non-NULL values: 0, FALSE, ''",
          "representative": "0, FALSE, ''",
          "why_distinct": "Falsy values are NOT treated as NULL → kept in output"
        }
      ],
      "spanning_proof": "Partitions cover: {empty set} ∪ {all scalar NULL combinations} ∪ {single non-NULL} ∪ {multiple non-NULL} ∪ {all castable types: STRING, INTEGER, DECIMAL, BOOLEAN, DATE, TIMESTAMP} ∪ {ARRAY<STRING> with all element scenarios: empty, non-NULL elements, NULL elements, all NULL} ∪ {mixed scalar+array} ∪ {expressions}. This spans the complete variadic argument domain. Every possible argument combination falls into at least one partition."
    }
  ],
  "output_range": {
    "type": "STRING ∪ {NULL}",
    "bounds": [
      "sep IS NULL → output ALWAYS NULL (override)",
      "No survivors after NULL filtering → output ALWAYS '' (empty string)",
      "Single survivor → output = that value (no separator)",
      "Multiple survivors → output = values joined with separator between",
      "Empty strings are kept → consecutive separators possible in output",
      "Array arguments → expanded to individual elements then joined"
    ],
    "relationship": "Output is concatenation of surviving (non-NULL) values with separator inserted between each pair. Arrays are flattened first."
  },
  "codomain_classes": [
    {
      "id": "O_NULL",
      "predicate": "sep IS NULL",
      "covered_by": ["query_1"],
      "description": "NULL separator forces NULL output"
    },
    {
      "id": "O_EMPTY",
      "predicate": "No surviving values OR no arguments",
      "covered_by": ["query_2", "query_3"],
      "description": "Empty string when nothing to concatenate"
    },
    {
      "id": "O_SINGLE_VAL",
      "predicate": "Exactly 1 survivor",
      "covered_by": ["query_4"],
      "description": "Single value without separator"
    },
    {
      "id": "O_JOINED",
      "predicate": "2+ survivors, standard join",
      "covered_by": ["query_5", "query_6"],
      "description": "Standard concatenation with separator"
    },
    {
      "id": "O_JOINED_EMPTY",
      "predicate": "Survivors include empty string",
      "covered_by": ["query_7"],
      "description": "Consecutive separators from empty strings"
    },
    {
      "id": "O_CAST_INT",
      "predicate": "Integer values cast to string",
      "covered_by": ["query_8"],
      "description": "Integer implicit cast"
    },
    {
      "id": "O_CAST_DECIMAL",
      "predicate": "Decimal values cast to string",
      "covered_by": ["query_9"],
      "description": "Decimal implicit cast with precision"
    },
    {
      "id": "O_CAST_NEGATIVE",
      "predicate": "Negative numbers cast to string",
      "covered_by": ["query_10"],
      "description": "Sign preserved in cast"
    },
    {
      "id": "O_CAST_BOOL",
      "predicate": "Boolean values cast to string",
      "covered_by": ["query_11"],
      "description": "Boolean to lowercase string"
    },
    {
      "id": "O_CAST_DATE",
      "predicate": "DATE cast to string",
      "covered_by": ["query_12"],
      "description": "Date in ISO format"
    },
    {
      "id": "O_CAST_TIMESTAMP",
      "predicate": "TIMESTAMP cast to string",
      "covered_by": ["query_13"],
      "description": "Timestamp in ISO format with time"
    },
    {
      "id": "O_ARRAY_EXPANDED",
      "predicate": "Array expanded and joined",
      "covered_by": ["query_14"],
      "description": "Array elements become individual values"
    },
    {
      "id": "O_ARRAY_WITH_NULLS",
      "predicate": "Array with NULLs expanded",
      "covered_by": ["query_15"],
      "description": "NULLs skipped in array expansion"
    },
    {
      "id": "O_EMPTY_ARRAY",
      "predicate": "Empty array contributes nothing",
      "covered_by": ["query_16"],
      "description": "Zero-element array yields empty string"
    },
    {
      "id": "O_ARRAY_PLUS_SCALAR",
      "predicate": "Array and scalar mixed",
      "covered_by": ["query_17"],
      "description": "Array flattened then joined with scalar"
    },
    {
      "id": "O_MIXED_TYPES",
      "predicate": "Multiple types cast and joined",
      "covered_by": ["query_18"],
      "description": "All types cast then concatenated"
    },
    {
      "id": "O_NESTED_FUNCTION",
      "predicate": "Function expressions evaluated",
      "covered_by": ["query_19"],
      "description": "Expression results joined"
    },
    {
      "id": "O_ALL_NULL_ARRAY",
      "predicate": "Array with all NULLs",
      "covered_by": ["query_20"],
      "description": "All array elements skipped → empty"
    },
    {
      "id": "O_FALSY_VALUES",
      "predicate": "Falsy non-NULL values kept",
      "covered_by": ["query_21"],
      "description": "0, FALSE, '' are NOT NULL → kept"
    },
    {
      "id": "O_MULTI_SEP",
      "predicate": "Multi-character separator used",
      "covered_by": ["query_22"],
      "description": "Multi-char separator between values"
    },
    {
      "id": "O_EMPTY_SEP",
      "predicate": "Empty separator → direct concat",
      "covered_by": ["query_23"],
      "description": "No delimiter between values"
    },
    {
      "id": "O_SEP_CAST_INT",
      "predicate": "Integer separator cast to string",
      "covered_by": ["query_24"],
      "description": "Separator also undergoes implicit cast"
    }
  ],
  "surjectivity_check": {
    "total_codomain_classes": 22,
    "covered_classes": 22,
    "coverage": 1.0,
    "uncovered_classes": []
  },
  "mathematical_proof": {
    "spanning": "For separator: {NULL} ∪ {empty} ∪ {single char} ∪ {multi char} ∪ {castable types} = complete separator domain. For arguments: {no args} ∪ {all NULL} ∪ {single} ∪ {multiple} ∪ {all scalar types} ∪ {all array scenarios} ∪ {mixed} = complete variadic domain. Every possible input falls into exactly one partition per parameter.",
    "surjectivity": "All 22 codomain classes have at least one query producing output in that class. Coverage = 22/22 = 1.0. Complete.",
    "completeness": "SPANNING ∧ SURJECTIVITY = TRUE ∧ TRUE = COMPLETE. The basis is mathematically complete."
  },
  "key_insights": [
    "NULL separator forces NULL output regardless of arguments (override)",
    "NULL arguments are skipped (filtered out) before joining",
    "Empty string '' is NOT NULL → kept in output → can create consecutive separators",
    "Arrays are expanded (flattened) into individual elements before joining",
    "NULL elements within arrays are also skipped",
    "Empty arrays contribute zero elements (distinct from scalar NULL)",
    "All scalar types undergo implicit cast to string",
    "Falsy values (0, FALSE, '') are NOT treated as NULL",
    "Separator can also be a castable type (e.g., integer)",
    "Function expressions are evaluated first, then results are joined",
    "No arguments after separator → empty string (not NULL)"
  ]
}
