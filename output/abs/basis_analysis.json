{
  "function": "ABS",
  "dialect": "spark",
  "parameter_analysis": {
    "n": {
      "real_domain": "NUMERIC (INT, BIGINT, DECIMAL, DOUBLE) ∪ {NULL}",
      "partitions": [
        {
          "name": "P_NULL",
          "predicate": "n IS NULL",
          "representative": "NULL",
          "reasoning": "NULL propagation — standard SQL NULL handling"
        },
        {
          "name": "P_NEGATIVE_INT",
          "predicate": "n IS NOT NULL AND n < 0 AND n ∈ INTEGER",
          "representative": "-5",
          "reasoning": "Negative integer — returns |n|"
        },
        {
          "name": "P_ZERO",
          "predicate": "n IS NOT NULL AND n = 0",
          "representative": "0",
          "reasoning": "Zero — ABS(0) = 0"
        },
        {
          "name": "P_POSITIVE_INT",
          "predicate": "n IS NOT NULL AND n > 0 AND n ∈ INTEGER",
          "representative": "5",
          "reasoning": "Positive integer — identity: ABS(n) = n"
        },
        {
          "name": "P_NEGATIVE_DECIMAL",
          "predicate": "n IS NOT NULL AND n < 0 AND n ∈ DECIMAL",
          "representative": "-3.14",
          "reasoning": "Negative decimal — returns |n|"
        },
        {
          "name": "P_POSITIVE_DECIMAL",
          "predicate": "n IS NOT NULL AND n > 0 AND n ∈ DECIMAL",
          "representative": "2.71",
          "reasoning": "Positive decimal — identity: ABS(n) = n"
        },
        {
          "name": "P_MIN_BIGINT",
          "predicate": "n = -9223372036854775808 (MIN BIGINT)",
          "representative": "-9223372036854775808",
          "reasoning": "Boundary case — minimum BIGINT value"
        },
        {
          "name": "P_STRING_CAST",
          "predicate": "n is STRING castable to INT",
          "representative": "CAST('-10' AS INT)",
          "reasoning": "Implicit type conversion then ABS"
        }
      ],
      "spanning_proof": "Partitions cover: {NULL} ∪ {negative integers} ∪ {0} ∪ {positive integers} ∪ {negative decimals} ∪ {positive decimals} ∪ {BIGINT boundary} ∪ {castable types}. SPAN COMPLETE."
    }
  },
  "output_analysis": {
    "range": "R(ABS) = {NULL} ∪ {0} ∪ ℝ⁺",
    "type_bounds": "Same type as input, or NULL",
    "value_bounds": "output ≥ 0 when not NULL",
    "special_properties": [
      "ABS(NULL) = NULL",
      "ABS(0) = 0",
      "ABS(n) = n for n > 0 (identity)",
      "ABS(n) = -n for n < 0 (negation)"
    ],
    "codomain_classes": [
      {
        "name": "O_NULL",
        "predicate": "output IS NULL",
        "reasoning": "NULL input propagation",
        "covered_by": ["query 1: NULL input"]
      },
      {
        "name": "O_ZERO",
        "predicate": "output = 0",
        "reasoning": "ABS(0) = 0",
        "covered_by": ["query 3: zero input"]
      },
      {
        "name": "O_POSITIVE_INT",
        "predicate": "output > 0 AND output ∈ INTEGER",
        "reasoning": "Absolute value of integer input",
        "covered_by": ["query 2: -5→5", "query 4: 5→5", "query 8: cast"]
      },
      {
        "name": "O_POSITIVE_DECIMAL",
        "predicate": "output > 0 AND output ∈ DECIMAL",
        "reasoning": "Absolute value of decimal input",
        "covered_by": ["query 5: -3.14→3.14", "query 6: 2.71→2.71"]
      },
      {
        "name": "O_LARGE_INT",
        "predicate": "output > 2^62",
        "reasoning": "Large absolute values near BIGINT boundary",
        "covered_by": ["query 7: MIN BIGINT boundary"]
      }
    ],
    "surjectivity": {
      "total_classes": 5,
      "covered_classes": 5,
      "coverage_ratio": 1.0,
      "status": "COMPLETE"
    }
  },
  "basis_statistics": {
    "total_queries": 8,
    "total_partitions": 8,
    "total_codomain_classes": 5,
    "spanning_complete": true,
    "surjectivity_complete": true,
    "basis_minimal": true
  },
  "completeness_proof": {
    "input_spanning": "PROVEN — all numeric types and NULL covered",
    "output_surjectivity": "PROVEN — all 5 codomain classes covered",
    "mathematical_completeness": "COMPLETE"
  }
}